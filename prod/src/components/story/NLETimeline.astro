---
import type { TimelineEvent } from '../../types';

interface Props {
  events: TimelineEvent[];
}

const { events } = Astro.props;

// Helper to extract a numeric year from string (handles "1981", "Late 1990s", "2000s", "Present", etc.)
function extractYear(yearStr: string): number | null {
  // Try to find a 4-digit year first
  const fourDigitMatch = yearStr.match(/\b(19|20)\d{2}\b/);
  if (fourDigitMatch) {
    return parseInt(fourDigitMatch[0], 10);
  }
  // Handle decade strings like "2000s"
  const decadeMatch = yearStr.match(/\b(19|20)\d0s\b/);
  if (decadeMatch) {
    return parseInt(decadeMatch[0].replace('s', ''), 10);
  }
  // Handle "Present" - use current decade
  if (yearStr.toLowerCase().includes('present')) {
    return Math.floor(new Date().getFullYear() / 10) * 10;
  }
  return null;
}

// Extract unique decades for the timeline clips
const decadesSet = new Set<number>();
events.forEach(e => {
  const year = extractYear(e.year);
  if (year !== null) {
    decadesSet.add(Math.floor(year / 10) * 10);
  }
});
const decades = [...decadesSet].sort((a, b) => a - b);

// Clip colors based on position (like Premiere Pro clip colors)
const clipColors = ['#3b82f6', '#8b5cf6', '#ec4899', '#f59e0b', '#10b981', '#06b6d4'];
---

<nav
  class="nle-timeline"
  role="navigation"
  aria-label="Timeline navigation"
>
  <!-- Toolbar background -->
  <div class="nle-toolbar">
    <!-- Left section: TIMELINE label -->
    <div class="nle-label-section">
      <span class="nle-icon" aria-hidden="true">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="2" y="3" width="20" height="14" rx="2"/>
          <line x1="8" y1="21" x2="16" y2="21"/>
          <line x1="12" y1="17" x2="12" y2="21"/>
        </svg>
      </span>
      <span class="nle-title">TIMELINE</span>
    </div>

    <!-- Center: Timecode display -->
    <div class="nle-timecode-display">
      <span class="nle-timecode" aria-live="polite" aria-label="Current timeline position">
        <span class="tc-value" data-tc>00:00:00:00</span>
      </span>
    </div>

    <!-- Right section: Era label -->
    <div class="nle-era-display">
      <span class="nle-era-label" data-era-label>The Beginning</span>
    </div>
  </div>

  <!-- Timeline tracks area -->
  <div class="nle-tracks">
    <!-- Track label -->
    <div class="nle-track-label" aria-hidden="true">
      <span>V1</span>
    </div>

    <!-- Timeline ruler and clips -->
    <div class="nle-track-content">
      <!-- Grid background -->
      <div class="nle-grid" aria-hidden="true"></div>

      <!-- Clips -->
      <div class="nle-clips" role="tablist" aria-label="Career decades">
        {decades.map((decade, index) => {
          const decadeEvents = events.filter(e => {
            const year = extractYear(e.year);
            return year !== null && Math.floor(year / 10) * 10 === decade;
          });
          const clipColor = clipColors[index % clipColors.length];
          const eraTitle = decadeEvents[0]?.title || `${decade}s`;

          return (
            <button
              class="nle-clip"
              role="tab"
              aria-selected="false"
              data-decade={decade}
              data-era-title={eraTitle}
              style={`--clip-color: ${clipColor}`}
              tabindex={index === 0 ? 0 : -1}
            >
              <span class="clip-label">{decade}s</span>
            </button>
          );
        })}
      </div>

      <!-- Playhead -->
      <div class="nle-playhead" aria-hidden="true" data-playhead>
        <div class="playhead-head"></div>
        <div class="playhead-line"></div>
      </div>
    </div>
  </div>
</nav>

<style>
  .nle-timeline {
    position: sticky;
    top: 4rem; /* Below main nav */
    z-index: 40;
    background: #1a1a1a;
    border-bottom: 1px solid #333;
    font-family: var(--font-mono);
  }

  /* Toolbar */
  .nle-toolbar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.5rem 1rem;
    background: linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 100%);
    border-bottom: 1px solid #333;
  }

  .nle-label-section {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .nle-icon {
    width: 16px;
    height: 16px;
    color: #666;
  }

  .nle-title {
    font-size: 0.65rem;
    font-weight: 500;
    letter-spacing: 0.1em;
    color: #888;
    text-transform: uppercase;
  }

  /* Timecode display */
  .nle-timecode-display {
    display: flex;
    align-items: center;
  }

  .nle-timecode {
    background: #0a0a0a;
    padding: 0.25rem 0.75rem;
    border-radius: 2px;
    border: 1px solid #333;
  }

  .tc-value {
    font-size: 0.875rem;
    font-weight: 500;
    color: var(--color-nle-timecode);
    letter-spacing: 0.05em;
    font-variant-numeric: tabular-nums;
  }

  /* Era display */
  .nle-era-display {
    min-width: 120px;
    text-align: right;
  }

  .nle-era-label {
    font-size: 0.7rem;
    color: #888;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 150px;
    display: inline-block;
  }

  /* Tracks area */
  .nle-tracks {
    display: flex;
    height: 48px;
    background: #0f0f0f;
  }

  .nle-track-label {
    width: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #1a1a1a;
    border-right: 1px solid #333;
    font-size: 0.65rem;
    font-weight: 600;
    color: #666;
  }

  .nle-track-content {
    flex: 1;
    position: relative;
    overflow: hidden;
  }

  /* Grid background */
  .nle-grid {
    position: absolute;
    inset: 0;
    background-image:
      linear-gradient(90deg, #222 1px, transparent 1px),
      linear-gradient(90deg, #1a1a1a 1px, transparent 1px);
    background-size: 80px 100%, 16px 100%;
    opacity: 0.5;
  }

  /* Clips container */
  .nle-clips {
    position: relative;
    display: flex;
    gap: 4px;
    height: 100%;
    padding: 8px;
    z-index: 1;
  }

  /* Individual clip */
  .nle-clip {
    flex: 1;
    height: 100%;
    background: var(--clip-color);
    border: none;
    border-radius: 4px;
    cursor: pointer;
    position: relative;
    overflow: hidden;
    transition: all 0.15s ease;
    box-shadow:
      inset 0 1px 0 rgba(255, 255, 255, 0.15),
      inset 0 -1px 0 rgba(0, 0, 0, 0.3);
  }

  .nle-clip::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(180deg, rgba(255, 255, 255, 0.1) 0%, transparent 50%, rgba(0, 0, 0, 0.2) 100%);
    pointer-events: none;
  }

  .nle-clip:hover {
    filter: brightness(1.15);
    transform: translateY(-1px);
  }

  .nle-clip:focus-visible {
    outline: 2px solid var(--color-nle-clip-active);
    outline-offset: 2px;
  }

  .nle-clip[aria-selected="true"] {
    box-shadow:
      0 0 0 2px var(--color-nle-clip-active),
      inset 0 1px 0 rgba(255, 255, 255, 0.15),
      inset 0 -1px 0 rgba(0, 0, 0, 0.3);
  }

  .clip-label {
    position: absolute;
    left: 8px;
    top: 50%;
    transform: translateY(-50%);
    font-family: var(--font-mono);
    font-size: 0.6rem;
    font-weight: 600;
    color: rgba(255, 255, 255, 0.9);
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
    white-space: nowrap;
  }

  /* Playhead */
  .nle-playhead {
    position: absolute;
    top: 0;
    bottom: 0;
    left: 8px;
    width: 2px;
    z-index: 10;
    pointer-events: none;
    transition: left 0.1s ease-out;
  }

  .playhead-head {
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 12px;
    height: 10px;
    background: var(--color-nle-playhead);
    clip-path: polygon(0 0, 100% 0, 50% 100%);
  }

  .playhead-line {
    position: absolute;
    top: 10px;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 2px;
    background: var(--color-nle-playhead);
  }

  /* Responsive */
  @media (max-width: 640px) {
    .nle-toolbar {
      padding: 0.375rem 0.75rem;
    }

    .nle-timecode-display {
      display: none;
    }

    .nle-era-display {
      min-width: auto;
    }

    .nle-era-label {
      max-width: 100px;
    }

    .nle-track-label {
      width: 32px;
      font-size: 0.55rem;
    }

    .nle-tracks {
      height: 40px;
    }

    .clip-label {
      font-size: 0.5rem;
      left: 4px;
    }

    .nle-clips {
      padding: 6px;
      gap: 3px;
    }
  }

  @media (max-width: 480px) {
    .nle-label-section .nle-title {
      display: none;
    }

    .nle-era-label {
      max-width: 80px;
      font-size: 0.6rem;
    }
  }

  /* Reduced motion */
  @media (prefers-reduced-motion: reduce) {
    .nle-clip {
      transition: none;
    }

    .nle-clip:hover {
      transform: none;
    }

    .nle-playhead {
      transition: none;
    }
  }
</style>

<script>
  function initNLETimeline() {
    const timeline = document.querySelector('.nle-timeline');
    if (!timeline) return;

    const clips = timeline.querySelectorAll<HTMLButtonElement>('.nle-clip');
    const playhead = timeline.querySelector<HTMLElement>('[data-playhead]');
    const timecodeEl = timeline.querySelector<HTMLElement>('[data-tc]');
    const eraLabelEl = timeline.querySelector<HTMLElement>('[data-era-label]');
    const trackContent = timeline.querySelector<HTMLElement>('.nle-track-content');

    if (!clips.length || !playhead || !trackContent) return;

    // Get all era sections
    const eraSections = document.querySelectorAll<HTMLElement>('[data-era]');
    if (!eraSections.length) return;

    // Calculate playhead position based on scroll
    function updatePlayhead() {
      const scrollTop = window.scrollY;
      const docHeight = document.documentElement.scrollHeight - window.innerHeight;
      const scrollPercent = Math.min(Math.max(scrollTop / docHeight, 0), 1);

      // Move playhead across the track
      const trackWidth = trackContent!.offsetWidth - 16; // Account for padding
      const playheadPos = 8 + (scrollPercent * trackWidth);
      playhead!.style.left = `${playheadPos}px`;

      // Update timecode display
      if (timecodeEl) {
        // Simulate timecode based on scroll (assuming ~2 hour runtime)
        const totalFrames = Math.floor(scrollPercent * 2 * 60 * 60 * 30); // 2 hours at 30fps
        const hours = Math.floor(totalFrames / (60 * 60 * 30)).toString().padStart(2, '0');
        const minutes = Math.floor((totalFrames % (60 * 60 * 30)) / (60 * 30)).toString().padStart(2, '0');
        const seconds = Math.floor((totalFrames % (60 * 30)) / 30).toString().padStart(2, '0');
        const frames = (totalFrames % 30).toString().padStart(2, '0');
        timecodeEl.textContent = `${hours}:${minutes}:${seconds}:${frames}`;
      }

      // Find current era based on viewport
      let currentEra: HTMLElement | null = null;
      const viewportMiddle = scrollTop + window.innerHeight / 2;

      eraSections.forEach(section => {
        const rect = section.getBoundingClientRect();
        const sectionTop = rect.top + scrollTop;
        const sectionBottom = sectionTop + rect.height;

        if (viewportMiddle >= sectionTop && viewportMiddle < sectionBottom) {
          currentEra = section;
        }
      });

      // Update active clip
      clips.forEach(clip => {
        const decade = clip.dataset.decade;
        const isActive = currentEra?.dataset.era?.startsWith(decade || '');
        clip.setAttribute('aria-selected', isActive ? 'true' : 'false');

        if (isActive && eraLabelEl) {
          eraLabelEl.textContent = clip.dataset.eraTitle || '';
        }
      });
    }

    // Click to navigate
    clips.forEach(clip => {
      clip.addEventListener('click', () => {
        const decade = clip.dataset.decade;
        const targetSection = document.querySelector<HTMLElement>(`[data-era^="${decade}"]`);

        if (targetSection) {
          const offset = 120; // Account for sticky headers
          const targetPos = targetSection.getBoundingClientRect().top + window.scrollY - offset;

          window.scrollTo({
            top: targetPos,
            behavior: window.matchMedia('(prefers-reduced-motion: reduce)').matches ? 'auto' : 'smooth'
          });
        }
      });
    });

    // Keyboard navigation
    clips.forEach((clip, index) => {
      clip.addEventListener('keydown', (e) => {
        let nextIndex = index;

        if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
          e.preventDefault();
          nextIndex = Math.min(index + 1, clips.length - 1);
        } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
          e.preventDefault();
          nextIndex = Math.max(index - 1, 0);
        } else if (e.key === 'Home') {
          e.preventDefault();
          nextIndex = 0;
        } else if (e.key === 'End') {
          e.preventDefault();
          nextIndex = clips.length - 1;
        }

        if (nextIndex !== index) {
          clips[index].setAttribute('tabindex', '-1');
          clips[nextIndex].setAttribute('tabindex', '0');
          clips[nextIndex].focus();
        }
      });
    });

    // Throttled scroll handler
    let ticking = false;
    function onScroll() {
      if (!ticking) {
        requestAnimationFrame(() => {
          updatePlayhead();
          ticking = false;
        });
        ticking = true;
      }
    }

    window.addEventListener('scroll', onScroll, { passive: true });
    window.addEventListener('resize', updatePlayhead);

    // Initial update
    updatePlayhead();

    // Cleanup
    return () => {
      window.removeEventListener('scroll', onScroll);
      window.removeEventListener('resize', updatePlayhead);
    };
  }

  // Initialize
  initNLETimeline();

  // Re-initialize after view transitions
  document.addEventListener('astro:after-swap', initNLETimeline);
</script>
